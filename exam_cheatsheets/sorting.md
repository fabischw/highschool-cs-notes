# --Generated by New Bing AI (beta testing stage)--
#### Explanations generated by ChatGPT
#### -checked and reviewed by [fabischw](https://github.com/fabischw)-
#### -the response was modified slightly-



# Sorting Algorithms in Python

**Insertion Sort**
```python
def insertion_sort(L):
    for i in range(len(L)):
        for j in range(0, i):
            if L[j] > L[i]:
                # swap L[j] and L[i]
                L[j], L[i] = L[i], L[j]
    return L
```

- Space Complexity: O(1)
- Time Complexity: O(n^2) in the worst and average case, O(n) in the best case
- Video Link: https://www.youtube.com/watch?v=JMRU2nh6bfs

<details>
<summary>Explanation</summary>

1. The input is a list of elements, L.
2. The outer loop runs len(L) times, as each iteration inserts one element into the sorted part of the list.
3. In each iteration, the variable i is the index of the element to be inserted into the sorted part of the list.
4. The inner loop runs from 0 to i-1, as these are the indices of the elements in the sorted part of the list that are potentially greater than L[i].
5. If the element at index j is greater than the element at index i, the elements are swapped so that L[i] is inserted into its proper position in the sorted part of the list.
7. After the inner loop completes, the first i+1 elements of the list are sorted.
8. The sorted list is returned.

</details>




**Selection Sort**
```python
def selection_sort(L):
    for i in range(len(L)):
        # find index of minimum element in unsorted part
        min_index = i
        for j in range(i+1, len(L)):
            if L[j] < L[min_index]:
                min_index = j
        # swap minimum element with first element of unsorted part
        L[i], L[min_index] = L[min_index], L[i]
    return L
```

- Space Complexity: O(1)
- Time Complexity: O(n^2) in all cases
- Video Link: https://www.youtube.com/watch?v=6S_mu-U0VTI

<details>
<summary>Explanation</summary>

1. The input is a list of elements, L.
2. The outer loop runs len(L) times, as each iteration selects the minimum element from the unsorted part of the list and places it at the beginning.
3. In each iteration, the variable min_index is set to i, which is the index of the first element in the unsorted part of the list.
4. The inner loop runs from i+1 to len(L), as the first i elements are already sorted.
5. If the element at index j is less than the element at index min_index, the variable min_index is set to j.
6. After the inner loop completes, the minimum element in the unsorted part of the list is at index min_index.
7. The minimum element is swapped with the first element in the unsorted part of the list, which is at index i.
8. The sorted list is returned.

</details>




**Bubble Sort**
```python
def bubble_sort(L):
    n = len(L)
    swapped = False # flag to check if any swap occurred
    for i in range(n-1):
        for j in range(0, n-i-1):
            if L[j] > L[j+1]:
                swapped = True # swap occurred
                # swap adjacent elements if they are out of order
                L[j], L[j+1] = L[j+1],L[j]
        if not swapped:
            break # no swap means list is already sorted
    return L
```

- Space Complexity: O(1)
- Time Complexity: O(n^2) in the worst and average case, O(n) in the best case
- Video Link: https://www.youtube.com/watch?v=ARZLBeagiJ4

<details>
<summary>Explanation</summary>

1. The input is a list of elements, L.
2. The length of the list is stored in the variable n.
3. A flag, swapped, is initialized to False.
4. The outer loop runs n-1 times, as each iteration moves the largest unsorted element to the end of the list.
5. The inner loop runs from the beginning of the list to n-i-1, as the last i elements are already sorted.
6. If the element at index j is greater than the element at index j+1, the elements are swapped and swapped is set to True.
7. After the inner loop completes, if swapped is still False, it means that the list is already sorted and the algorithm terminates early.
8. The sorted list is returned.

</details>




